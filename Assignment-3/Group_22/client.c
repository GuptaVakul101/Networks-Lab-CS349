#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <arpa/inet.h>
#include <signal.h>
#include <math.h>
#define MAXLINE 1000

bool c_s_connected;

// contains the content of the message and unique ID of message type
typedef struct Message {
	int type_id;
	char msg[MAXLINE];
} Message;


Message* char_to_message(char* inp){
	Message* opt = (Message*) malloc(sizeof(Message));

	strcpy(opt->msg, inp + 1);
	opt->type_id = (int) (inp[0] - '0');
	return opt;
}

char* message_to_char(Message m){
	char *opt = (char*) malloc((1+MAXLINE)*sizeof(char));

	opt[0] = (char) ((int) '0' + m.type_id);
	int i;
	strcpy(opt+1, m.msg);
	return opt;
}


/**
 - converts a char array to an int array by converting each byte to its binary representation
   and storing this in an int array. Also it adds 0 padding so that total no of bits are divisible by 6
 - blen = length of returned int array
 - len = length of base64 encoded msg generated by encoding msg.
 - Example :
 		ex. msg = "ABC";
		returns array = {1,0,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1}
		blen = 21
		len = 4
 **/
int *char_to_bits(char *msg, int *len, int *blen){

	int n = strlen(msg);
	int sz = n*8;
	if(sz%6)
		sz += (6 -sz%6);
	*len = sz/6;
	if(n%3==1)
		(*len)+=2;
	if(n%3==2)
		(*len)+=1;
	*blen = sz;
	int *bits = (int *)malloc(sz*sizeof(int));
	int idx = 0,i,j;
	for(i = 0;i < n;i++){
		int p  = (int)msg[i];
		for(j=0;j<8;j++){
			bits[idx + 7-j] = (p%2);
			p/=2;
		}
		idx += 8;
	}
	for(i=idx;i<sz;i++)
		bits[i] = 0;
	return bits;
}

char mapchar(int i){
    if(i < 26)
        return 'A' + i;
    else if(i < 52)
        return 'a' + i -26;
    else if(i < 62)
        return '0' + i - 52;
    else
        return (i == 62)? '+':'/';
}


// bits = int array of 1s and 0s only.
//returns ascii char represented by the binary value from bits[s] to bits[e].
char binary_to_char(int *bits, int s,int e) {
	int p = 0,i;
	for(i=e;i>=s;i--)
		p = p + bits[i]*(1 << e-i);
	return mapchar(p);
}


// encodes char array data to base64 encoded format.
//Returns the encoded data in the original array thus modifying it.
void encode(char*data) {
	int f,i,j;
	int n = strlen(data);
	char msg[MAXLINE];
	strcpy(msg, data);

	for(i=0;i<strlen(data);i++) {
		if(data[i] == '\r' || data[i] == '\n' || data[i] == '\0') {
			f = i;
			break;
		}
	}
	msg[f] = '\0';

	int encoded_len, bits_len;
	int *bits = char_to_bits(msg, &encoded_len, &bits_len);
	char *encoded_msg = (char*) malloc((encoded_len+n-f+1)*sizeof(char));
	for(i=0;i<bits_len/6;i++)
		encoded_msg[i] = binary_to_char(bits, i*6, i*6 + 5);
	for(i=bits_len/6;i<encoded_len;i++)
		encoded_msg[i] = '=';
	encoded_msg[encoded_len] = '\0';
	int p = encoded_len;
    for(i=p;i<p+(n-f+1);i++)
		encoded_msg[i] = data[f + i-p];
	strcpy(data, encoded_msg);
    free(encoded_msg);
	free(bits);
}


// converts decimal to binary numbers and returns the binary reprsentation in char array temp[i].
void decimalToBinary_d(long n, char temp[][6], int I ) {
    int remainder;
    int j = 5;
    while(n != 0) {
        remainder = n%2;
        n = n/2;
		if(remainder == 0)		temp[I][j] = '0';
		else					temp[I][j] = '1';
		j--;
	}

    int i;
    for(i=0;i<=j;i++)
	temp[I][i] = '0';

}


// converts a binary array representing an int to its decimal form and return it as int.
int binaryToDecimal_d(char *t ){
    int decimal = 0, i = 0;
    while (i<8) {
        if(t[7-i] == '1')
        	decimal += (int) (1 << i);
        ++i;
    }
    return decimal;

}


/**
	- makes another copy of the message which contains the whole message except '\r', '\n', '\0'
	- evaluates the length of the original message by the considering the number of '=' appended
	- translates the encoded binary data into decimal format
	- appends the special characters ('\r' and '\n', '\0') after encoding the content
 **/
void decode(char *msg){
	char EncodedMessage[100000];
	int f,x;
	for(x=0;x<strlen(msg);x++){
		if(msg[x] == '\r' || msg[x] == '\n' || msg[x] == '\0'){
			f = x;
			break;
		}
	}

	for(x=0;x<f;x++)
		EncodedMessage[x] = msg[x];
	EncodedMessage[f] = '\0';

	int len = strlen(EncodedMessage);
	int sub = 0;
	int alen = len;
	if(EncodedMessage[len-1] == '='){
		if(EncodedMessage[len-2] == '='){
			alen = len-2;
			sub = 4;
		}
		else{
			alen = len-1;
			sub = 2;
		}
	}
	alen = (alen*6 - sub)/8;
    char code[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	int i,j;
	char temp[100000][6];
	char tempf[600000];

	for(i=0;i<strlen(EncodedMessage);i++) {
		for(j=0;j<=63;j++) {
			if(EncodedMessage[i]==code[j]) {
				decimalToBinary_d(j,temp,i);
				break;
			}
		}
	}

	int remai = strlen(EncodedMessage) * 6  - strlen(temp[0]);

	if(remai == 6) {
		int i;
		for(i=0;i<strlen(temp[0])-2;i++) // removed two 0
			tempf[i] = temp[0][i];
	}
	else if(remai == 12) {
		int i;
		for(i=0;i<strlen(temp[0])-4;i++)  // removed four 0
			tempf[i] = temp[0][i];
	}
	else {
		int i;
		for(i=0;i<strlen(temp[0]);i++)
			tempf[i] = temp[0][i];
	}


	char DecodedMessage[100000];
	int k = 0;

	int flag = strlen(tempf) / 8;
	int a = flag;
	while(flag){
		char x[8];
		int j;
		for(j=0;j<8;j++)
		    x[j] = tempf[(a-flag)*8 + j];
		DecodedMessage[k++] = (char) binaryToDecimal_d(x);
		flag--;
	}

	DecodedMessage[alen] = '\0';

	int p = strlen(DecodedMessage);
	int n = strlen(msg);
	for(x=p;x<p+(n-f+1);x++)
		DecodedMessage[x] = msg[f + x-p];
	strcpy(msg, DecodedMessage);
	for(i=0;i< 100000;i++)
		DecodedMessage[i] = '\0';
	for(i=0;i< 600000;i++)
		tempf[i] = '\0';
}

typedef struct sockaddr SA;
static int	read_cnt;
static char	*read_ptr;
static char	read_buf[MAXLINE];

static ssize_t my_read(int fd, char *ptr)
{
	if(read_cnt <= 0){
	again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)		goto again;
			return(-1);
		}
		else if (read_cnt == 0)		return(0);
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;
	return(1);
}

int cfd;


/**
  - reads stream of fd until \n, eof is found or error occurs or maxlen characters are read
  - \n is stored similar to fgets
 **/
ssize_t readline(int fd, void *vptr, size_t maxlen){
	ssize_t	n, rc;
	char ch, *current_ptr;

	current_ptr = (char *)vptr;

	for (n = 1; n < maxlen; n++)
	{
		if ( (rc = my_read(fd, &ch)) == 1)
		{
			*current_ptr++ = ch;
			if (ch == '\n')
				break;	//newline is stored
		}
		else if (rc == 0)
		{
			*current_ptr = 0;
			return(n - 1); //EOF occured and n-1 bytes were read
		}
		else 
			return(-1); //some error occured
	}

	*current_ptr = 0;	/* null terminate like fgets() */
	return(n);
}


ssize_t readlinebuf(void **vptrptr){
	if (read_cnt)
		*vptrptr = read_ptr;
	return(read_cnt);
}


// handles readline errors.
ssize_t Readline(int fd, void *ptr, size_t maxlen) {
	ssize_t n;

	if ( (n = readline(fd, ptr, maxlen)) < 0)
	{
		printf("Readline error\n");
		exit(1);
	}
	return(n);
}

// writes n bytes to a descriptor
ssize_t writen(int fd, const void *vptr, size_t n) {
    size_t left_bytes;
    ssize_t bytes_written;

    const char *current_ptr;
    current_ptr = (char *)vptr;

    left_bytes = n;
    while (left_bytes > 0)
    {
        if ( (bytes_written = write(fd, current_ptr, left_bytes)) <= 0) 
        {
            if (errno == EINTR)
                bytes_written = 0; //call write() again        
            else
                return(-1); //some error occured
        }

        left_bytes  -= bytes_written; //decreaing the left bytes
        current_ptr += bytes_written; //incrementing the current pointer
    }

    return(n);
}

// handles error if writen is unable to write n bytes.
void Writen(int fd, void *ptr, size_t nbytes){
    if (writen(fd, ptr, nbytes) != nbytes)
        perror("writen error");
}


// returns true if M starts with "close"
bool isClose(char *M){
	if(strlen(M) < 5)
		return false;
	if(M[0] == 'c' && M[1] == 'l' && M[2] == 'o' && M[3] == 's' && M[4] == 'e')
		return true;
	else
		return false;
}


void str_cli(FILE *fp, int socket_fd){
	char terminal_line[MAXLINE];
	char received_line[MAXLINE];

	while(fgets(terminal_line, MAXLINE, fp) != NULL)
	{
		Message m;
		if(isClose(terminal_line))
			m.type_id = 3;
		else
			m.type_id = 1;

		strcpy(m.msg,terminal_line);

		encode(m.msg);
		char *message_com = message_to_char(m); //converting the message to character format
		Writen(socket_fd, message_com, strlen(message_com)); 

		while(readline(socket_fd, received_line, MAXLINE) <= 0)
		{
			 printf("server terminated prematurely\n");
			 printf("closing sockets.....\n");
			 close(socket_fd);
			 printf("exiting....\n");
			 exit(0);
		}

		free(message_com);
		Message* c_msg = char_to_message(received_line);

		printf("\nMessage received from server:\n");
		printf("Type_id: %d\nEncoded message: %s",c_msg->type_id, c_msg->msg);
		decode(c_msg->msg);
		printf("Decoded message: %s\n",c_msg->msg);

		if(isClose(c_msg->msg))//if the message received from the server is 'close'
		{
			printf("server terminated prematurely\n");
			printf("closing sockets.....\n");
			close(socket_fd);
			printf("exiting....\n");
			exit(0);
		}
		free(c_msg);

		if(isClose(terminal_line)) //If the message written on terminal starts with 'close'
		{
			printf("closing socket....\n");
			close(socket_fd);
			printf("exiting client.....\n");
			exit(1);
		}
	}
}


// returns true if s is an integer
bool is_integer(char *s){
	int i;
	for(i=0;i<strlen(s);i++)
	{
		if(s[i] < '0' || s[i] > '9')
			return false;
	}
	return true;
}

void signalHandler(int signalValue){

	if(!c_s_connected){
		printf("Error connecting to server\n");
		exit(0);
	}

	printf("\nsending close to server..\n");
	char terminal_line[MAXLINE];
	snprintf(terminal_line, sizeof(terminal_line), "close");

	encode(terminal_line);

	Message m; //creating a close message with type 3!
	m.type_id = 3;
	strcpy(m.msg, terminal_line);

	char* m_com = message_to_char(m); //converting the message to character types
	Writen(cfd, m_com, strlen(m_com));
	free(m_com);

	printf("closing client sockets..\n"); //closing the client socket 
	close(cfd);

	printf("exiting..\n");
	exit(0);
}


int main(int argc, char **argv){

	/*signal Handler for ctrl-c and hence will send a message to server that client
	has benn closed*/
	signal(SIGINT, signalHandler); 

	if(argc != 3)
	{
		printf("Usage: <Executable> <IP address> <port>\n");
		exit(1);
	}

	if(!is_integer(argv[2]))
	{
		printf("Please mention the port correctly\n");
		exit(1);
	}

	// take server port and check for errors.
	int serv_port = atoi(argv[2]);
	if(serv_port < 0 || serv_port > 65535)
	{
		printf("Port number must be between 0 and 65535.\n");
	}

	printf("TO CLOSE CONNECTION: type 'close'(without quotes)\nWaiting for connection...\n");

	c_s_connected = false;

	// creating a socket on client side.
	int socket_fd;
	struct sockaddr_in serv_addr;
	socket_fd = socket(AF_INET, SOCK_STREAM, 0);
	cfd = socket_fd;

	// Filling the socket address structure
	bzero(&serv_addr, sizeof(serv_addr)); //fill serv_addr initially by NULL values
	serv_addr.sin_family = AF_INET; //set the family as IPv4
	serv_addr.sin_port = htons(serv_port); //set the port number
	inet_pton(AF_INET, argv[1], &serv_addr.sin_addr); //set the IP address

	// connect to server
	int cnt_status = connect(socket_fd, (SA *)&serv_addr, sizeof(serv_addr));
	if(cnt_status == -1){
		printf("Server does not exist\n");
		return 0;
	}

	printf("Connected!\n\n");
	c_s_connected = true;

	str_cli(stdin, socket_fd);

	return 0;
}
